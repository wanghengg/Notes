# Pulsar的概念和架构

## Pulsar关键特点

* 对 Pulsar 实例中的多个集群的原生支持，以及跨集群的消息无缝地理复制。
* 非常低的发布和端到端延迟
* 多种订阅模式（独占、共享、故障转移）
* 通过 Apache BookKeeper 提供的持久消息存储保证消息传递。
* 当数据老化时，分层存储将数据从热/温存储卸载到冷/长期存储（例如 S3 和 GCS）。
* 存储和计算费力，使得其有很好的伸缩性。

## Pulsar的消息

Pulsar使用pub-sub模式，生产者发送消息到topic，消费者订阅topic，处理来自topic的数据，并在处理完成后向broker发送确认消息。

**创建订阅时，即使消费者断开连接，Pulsar 也会保留所有消息。只有当消费者确认所有这些消息都已成功处理时，才会丢弃保留的消息。**

### message的组成

| 成分           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| payload        | message携带的数据，以二进制字节表示。                        |
| Key            | 消息可以选择用键标记，这对于topic compact（主题压缩）之类的事情很有用。 |
| Properties     | 用户定义的key/value属性。                                    |
| Producer name  | 生产者名字                                                   |
| Topic name     | topic名字                                                    |
| Schema version | 生成消息的模式的版本号。                                     |
| Sequence ID    | 每个 Pulsar 消息都属于其主题的有序序列。消息的序列 ID 最初由其生产者分配，指示其在该序列中的顺序，也可以自定义。 |
| Message ID     | 一旦消息被持久存储，消息的消息 ID 就由 bookie 分配。消息 ID 指示消息在分类帐中的特定位置，并且**在 Pulsar 集群中是唯一的**。 |
| Publish time   | 消息发布时的时间戳，由生产者自动产生。                       |
| Event time     | 应用程序附加到消息的可选时间戳。例如，应用程序在处理消息时附加时间戳。如果没有设置事件时间，则值为 0。 |

消息默认最大为5MB，可以通过broker.conf配置。

### Producer

#### 发送模式

生产者同步（**sync，生产者在发送每条消息之后等待来自broker的确认。如果没有收到确认，生产者将发送操作视为失败**）或异步（**async，生产者将消息放在一个阻塞队列并且立即返回，然后客户端库在后端将消息发送到broker。如果队列已满（队列大小可以设置），生产者调用API时会根据传入参数阻塞或者返回失败**）向broker发送消息。

#### 接入模式

| 接入模式         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| Shared           | 多个生产者可以向同一个topic发送message，这是默认设置。       |
| Exclusive        | 只有一个生产者可以向一个topic发送消息。如果有一个生产者已经连接上，其他生产者在连接时会立即失败。 |
| WaitForExclusive | 如果已经连接了生产者，则生产者的创建将处于挂起状态（而不是超时），直到生产者获得独占访问权。 |

#### 压缩

可以将生产者发布的消息在传输之前进行压缩。

#### 批处理

启用批处理后，生产者会在单个请求中累积并发送一批消息。 批处理大小由最大消息数和最大发布延迟定义。 因此，backlog 大小代表的是批处理的总数，而不是消息的总数。

一般来说，当一个批次的所有消息都被消费者确认时，它就会被确认。 这意味着当并非所有批次消息都被确认时，意外失败、否定确认或确认超时可能会导致重新传递此批次中的所有消息。

为了避免将一批确认的消息重新传递给消费者，Pulsar 从 Pulsar 2.6.0 开始引入了批量索引确认。 开启批量索引确认后，消费者过滤掉已经确认的批量索引，向broker发送批量索引确认请求。 broker维护批次索引确认状态并跟踪每个批次索引的确认状态，以避免向消费者发送已确认的消息。 当其中消息的所有索引都被确认时，该批次将被删除。

#### 分块

如果消息超过`maxMessageSize`参数定义的最大消息大小，生产者会将消息分块，然后将它们与分块元数据分开按顺序发布到broker；broker与普通消息一样存储这些分块消息，并使用`chunkMessageRate`记录topic上的分块消息率；然后消费者缓冲分块的消息并将它们聚合到消费者的 接收队列中；最后客户端消费这个聚合后的消息。

***注意***：

* 分块只适用于持久topic
* 分块只适用于独占和故障转移订阅类型。
* 分块不能和批处理同时使用。

### Consumer

消费者是一个通过订阅附加到topic然后接收消息的进程。

消费者向broker发送流许可请求以获取消息。 消费者端有一个队列，用于接收从代理推送的消息。 您可以使用 `receiverQueueSize `参数配置队列大小。 默认大小为 1000)。 每次调用` consumer.receive()` 时，都会从缓冲区中取出一条消息。

#### 接收模式

消息以同步（sync，阻塞直到有消息可以消费）或异步（async，立即返回，通过Future返回消息）的方式从代理接收。

#### 确认

消费者成功消费一条消息后，向broker发送确认请求。 然后，这条消费消息将被永久存储，只有在所有订阅都确认后才会被删除。 如果要存储消费者已确认的消息，则需要配置消息保留策略。

**消息确认有两种 方式：1）对每条消息确认；2）累计确认。通过调用不同的API实现**

#### 否定确认

否定确认机制允许您向代理发送通知，指示消费者未处理消息。 当消费者消费一条消息失败，需要重新消费时，消费者会向broker发送否定确认（nack），触发broker将这条消息重新传递给消费者。

消息被单独或累积地否定确认，具体取决于消费订阅类型：

* 在 Exclusive 和 Failover 订阅类型中，消费者只会否定确认他们收到的最后一条消息。
* 在 Shared 和 Key_Shared 订阅类型中，消费者可以单独否定确认消息。

请注意，对有序订阅类型（例如 Exclusive、Failover 和 Key_Shared）的否定确认可能会导致失败的消息按照原始顺序发送给消费者。

**如果要对消息使用否定确认，请确保在确认超时之前对其进行否定确认。**

#### 确认超时

确认超时机制允许您设置客户端跟踪未确认消息的时间范围。 在这个确认超时（`ackTimeout`）时间之后，客户端向broker发送重新发送未确认消息的请求，因此broker将未确认消息重新发送给消费者。

### 订阅

https://pulsar.apache.org/assets/images/pulsar-subscription-types-664733b68c7124129ca7d0e04dedcb96.png

